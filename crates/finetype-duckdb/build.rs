//! Build script for finetype_duckdb.
//!
//! When the `embed-models` feature is enabled, this script embeds the flat CharCNN
//! model weights, labels, and config at compile time via `include_bytes!`.

use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let models_base = PathBuf::from(&manifest_dir).join("../../models");

    // Rerun if models change
    println!("cargo:rerun-if-changed={}", models_base.display());

    #[cfg(feature = "embed-models")]
    generate_embedded_models(&models_base);

    #[cfg(not(feature = "embed-models"))]
    let _ = models_base;
}

#[cfg(feature = "embed-models")]
fn generate_embedded_models(models_base: &std::path::Path) {
    let flat_dir = models_base.join("char-cnn-v2");

    // Verify flat model exists
    assert!(
        flat_dir.join("model.safetensors").exists(),
        "Flat model not found at {:?}",
        flat_dir
    );

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest = PathBuf::from(&out_dir).join("embedded_models.rs");

    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs — do not edit\n");
    code.push_str("// Embeds model weights, labels, and configs at compile time.\n\n");

    // ── Flat model (char-cnn-v2) ───────────────────────────────────────
    let weights_path = flat_dir.join("model.safetensors").canonicalize().unwrap();
    let labels_path = flat_dir.join("labels.json").canonicalize().unwrap();
    let config_path = flat_dir.join("config.yaml").canonicalize().unwrap();

    code.push_str("// Flat CharCNN v2 model (151 types, single forward pass)\n");
    code.push_str(&format!(
        "pub const FLAT_WEIGHTS: &[u8] = include_bytes!(\"{}\");\n",
        weights_path.display()
    ));
    code.push_str(&format!(
        "pub const FLAT_LABELS: &[u8] = include_bytes!(\"{}\");\n",
        labels_path.display()
    ));
    code.push_str(&format!(
        "pub const FLAT_CONFIG: &[u8] = include_bytes!(\"{}\");\n",
        config_path.display()
    ));

    fs::write(&dest, code).unwrap_or_else(|e| panic!("Failed to write {}: {}", dest.display(), e));
}
