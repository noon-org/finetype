# FineType v2 — Identity Domain Definitions
#
# Hierarchy: domain.category.type (locale is a field, not in the key)
# Full label at inference time: domain.category.type.LOCALE
#
# Each definition is a transformation contract:
#   - broad_type:     Target DuckDB type
#   - format_string:  DuckDB strptime format (null if not strptime-based)
#   - transform:      DuckDB SQL expression ({col} = column placeholder)
#   - transform_ext:  Enhanced transform requiring a DuckDB extension
#   - validation:     JSON Schema fragment for data quality checks
#   - tier:           Path from root to parent in the inference graph
#   - decompose:      Optional struct expansion for multi-field output
#
# Identity domain covers:
#   - personal data (names, email, phone, credentials)
#   - demographic data (age, gender, nationality)
#   - financial data (credit cards, crypto addresses, payment methods)
#   - security data (passwords, tokens, usernames)
# ─────────────────────────────────────────────────────────────────────

# ═════════════════════════════════════════════════════════════════════
# CATEGORY: person
#
# Personally identifiable information (PII) and demographic data.
# WARNING: These types contain sensitive personal data. Handle with care
# and comply with data protection regulations (GDPR, CCPA, etc.).
# ═════════════════════════════════════════════════════════════════════

identity.person.full_name:
  title: "Full Name"
  description: >
    Complete person name (first and last names, possibly including middle names).
    Locale-specific due to name order and formatting conventions (e.g.,
    Western "FirstName LastName" vs East Asian "LastName FirstName").
  designation: locale_specific
  locales: [EN, EN_AU, EN_GB, EN_CA, EN_US, DE, FR, ES, IT, NL, PL, RU, JA, ZH, KO, AR]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose:
    first_name: "REGEXP_EXTRACT({col}, '^([^ ]+)')"
    last_name: "REGEXP_EXTRACT({col}, '([^ ]+)$')"
  validation:
    type: string
    minLength: 2
    maxLength: 200
    pattern: "^[\\p{L}\\s'\\-]+$"
  tier: [VARCHAR, person]
  release_priority: 5
  aliases: [name, fullname]
  samples:
    - "John Smith"
    - "María García"
    - "Jacques Dubois"
    - "田中太郎"
    - "محمد علي"
  references: null
  notes: >
    v1 migration: Was person.full_name. Locale-specific due to name order
    conventions. Simple decompose extracts first and last words; more sophisticated
    parsing requires NLP. Includes Unicode letter support for international names.

identity.person.first_name:
  title: "First Name"
  description: >
    Given name (first name). Locale-specific due to cultural naming conventions.
  designation: locale_specific
  locales: [EN, EN_AU, EN_GB, EN_CA, EN_US, DE, FR, ES, IT, NL, PL, RU, JA, ZH, KO, AR]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    minLength: 1
    maxLength: 100
    pattern: "^[\\p{L}\\s'\\-]+$"
  tier: [VARCHAR, person]
  release_priority: 4
  aliases: [given_name]
  samples:
    - "John"
    - "María"
    - "Jacques"
    - "太郎"
    - "محمد"
  references: null
  notes: >
    v1 migration: Was person.first_name. Locale-specific for cultural naming.
    Supports Unicode letters and common separators (apostrophes, hyphens).

identity.person.last_name:
  title: "Last Name"
  description: >
    Family name (surname). Locale-specific due to surname conventions which vary
    by culture (e.g., patronymic names in Scandinavian and Russian cultures).
  designation: locale_specific
  locales: [EN, EN_AU, EN_GB, EN_CA, EN_US, DE, FR, ES, IT, NL, PL, RU, JA, ZH, KO, AR]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    minLength: 1
    maxLength: 100
    pattern: "^[\\p{L}\\s'\\-]+$"
  tier: [VARCHAR, person]
  release_priority: 4
  aliases: [surname, family_name]
  samples:
    - "Smith"
    - "García"
    - "Dubois"
    - "田中"
    - "علي"
  references: null
  notes: >
    v1 migration: Was person.last_name (and person.surname). Locale-specific.
    Supports Unicode letters and common separators.

identity.person.email:
  title: "Email Address"
  description: >
    Standard email address (RFC 5322 simplified). Format: local@domain.
    Universal format but may include internationalized domain names (IDN).
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "LOWER(CAST({col} AS VARCHAR))"
  transform_ext: null
  decompose:
    local: "REGEXP_EXTRACT({col}, '^([^@]+)')"
    domain: "REGEXP_EXTRACT({col}, '@(.+)$')"
  validation:
    type: string
    pattern: "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$"
    minLength: 5
    maxLength: 254
  tier: [VARCHAR, person]
  release_priority: 5
  aliases: [email_address]
  samples:
    - "john.smith@example.com"
    - "user+tag@domain.org"
    - "test123@company.co.uk"
  references: null
  notes: >
    v1 migration: Was person.email. Transform lowercases for canonical form.
    Decompose extracts local and domain parts. Pattern uses simplified RFC 5322.

identity.person.phone_number:
  title: "Phone Number"
  description: >
    Telephone number in various formats. Locale-specific due to digit grouping,
    area code positions, and formatting conventions (e.g., US +1 (xxx) xxx-xxxx
    vs EU +xx-xxx-xxx-xxxx). May include country code, area code, and extension.
  designation: locale_specific
  locales: [EN, EN_AU, EN_GB, EN_CA, EN_US, DE, FR, ES, IT, NL, PL, RU, JA, ZH, KO, AR]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose:
    country_code: "REGEXP_EXTRACT({col}, '^\\+?([0-9]{1,3})')"
    area_code: "REGEXP_EXTRACT({col}, '[^0-9]([0-9]{3})[^0-9]')"
    digits_only: "REGEXP_REPLACE({col}, '[^0-9]', '')"
  validation:
    type: string
    minLength: 7
    maxLength: 20
    pattern: "^[+]?[0-9\\s()\\-\\.]+$"
  tier: [VARCHAR, person]
  release_priority: 4
  aliases: [telephone, phone]
  samples:
    - "+1 (555) 123-4567"
    - "555-123-4567"
    - "+44 20 7946 0958"
    - "+33 1 42 68 53 00"
    - "07911 123456"
  references: null
  notes: >
    v1 migration: Was person.phone_number (and person.telephone).
    Locale-specific for formatting. Decompose extracts country code, area code,
    and digits-only version. Pattern is permissive to handle various formats.

identity.person.username:
  title: "Username"
  description: >
    Online username or handle for a user account. Typically alphanumeric with
    underscores, hyphens, or dots. Case-insensitive storage. Locale-specific
    due to character set restrictions.
  designation: locale_specific
  locales: [EN, EN_AU, EN_GB, EN_CA, EN_US, DE, FR, ES, IT, NL, PL, RU]
  broad_type: VARCHAR
  format_string: null
  transform: "LOWER(CAST({col} AS VARCHAR))"
  transform_ext: null
  decompose: null
  validation:
    type: string
    minLength: 3
    maxLength: 32
    pattern: "^[a-zA-Z0-9_\\-.]{3,32}$"
  tier: [VARCHAR, person]
  release_priority: 4
  aliases: [handle, account_name]
  samples:
    - "john.smith"
    - "user_123"
    - "alice-wonderland"
    - "bob.jones_42"
  references: null
  notes: >
    v1 migration: Was person.username. Transform lowercases for canonical form.
    Typically 3-32 characters. Allows alphanumeric, underscore, hyphen, dot.

identity.person.password:
  title: "Password"
  description: >
    Authentication credential. Broad categorization due to high variance in
    format and strength requirements. Should never be stored in plaintext.
    Hash or encrypt passwords immediately.
  designation: broad_characters
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    minLength: 1
    maxLength: 255
  tier: [VARCHAR, person]
  release_priority: 0
  aliases: null
  samples:
    - "aB3#xY9@mK2"
    - "MySecureP@ss123"
    - "correct-horse-battery-staple"
  references: null
  notes: >
    v1 migration: Was person.password marked broad_characters. NEVER store
    plaintext passwords. Always hash (bcrypt, Argon2) or encrypt.
    Detection is for audit purposes only.

identity.person.gender:
  title: "Gender"
  description: >
    Gender identity. May be "Male", "Female", "Non-binary", "Other", or similar.
    Broad categorization due to variance in values and encoding.
  designation: broad_words
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    enum:
      - Male
      - Female
      - Non-binary
      - Other
      - Prefer not to say
      - Unknown
  tier: [VARCHAR, person]
  release_priority: 1
  aliases: null
  samples:
    - "Male"
    - "Female"
    - "Non-binary"
    - "Other"
  references: null
  notes: >
    v1 migration: Was person.gender marked broad_words. Enum is illustrative;
    actual values depend on data source. Consider inclusivity and cultural context.

identity.person.gender_code:
  title: "Gender Code"
  description: >
    Single character or short code representing gender (M, F, X, O, etc.).
    Broad categorization.
  designation: broad_words
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST(UPPER({col}) AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    pattern: "^[MFX]$"
  tier: [VARCHAR, person]
  release_priority: 1
  aliases: null
  samples:
    - "M"
    - "F"
    - "X"
  references: null
  notes: >
    v1 migration: Was person.gender_code marked broad_words. Single character
    or code. Transform uppercases. Common: M (male), F (female), X (other/not specified).

identity.person.gender_symbol:
  title: "Gender Symbol"
  description: >
    Unicode symbol representing gender (♂, ♀, ⚧, etc.).
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    pattern: "^[♂♀⚧⚪]$"
  tier: [VARCHAR, person]
  release_priority: 2
  aliases: null
  samples:
    - "♂"
    - "♀"
    - "⚧"
  references: null
  notes: >
    v1 migration: Was person.gender_symbol. Single Unicode symbol.

identity.person.nationality:
  title: "Nationality"
  description: >
    Country of citizenship or nationality. May be country name or ISO code.
    Locale-specific for country name representations.
  designation: locale_specific
  locales: [EN, EN_AU, EN_GB, EN_CA, EN_US, DE, FR, ES, IT, NL, PL, RU, JA, ZH, KO, AR]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    minLength: 2
    maxLength: 100
  tier: [VARCHAR, person]
  release_priority: 3
  aliases: [citizenship]
  samples:
    - "United States"
    - "Japan"
    - "Germany"
    - "France"
    - "Canada"
  references: null
  notes: >
    v1 migration: Was person.nationality. Locale-specific for country name
    representation (e.g., "Deutschland" in German vs "Germany" in English).
    May also appear as ISO country codes (US, JP, DE, etc.).

identity.person.blood_type:
  title: "Blood Type"
  description: >
    ABO blood group system (A, B, AB, O) with optional Rh factor (±).
    Format: "A+", "B-", "AB", "O+", etc.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "UPPER(CAST({col} AS VARCHAR))"
  transform_ext: null
  decompose:
    blood_group: "REGEXP_EXTRACT(UPPER({col}), '^([ABO]+)')"
    rh_factor: "REGEXP_EXTRACT(UPPER({col}), '([+-])$')"
  validation:
    type: string
    pattern: "^(A|B|AB|O)[+-]?$"
  tier: [VARCHAR, person]
  release_priority: 2
  aliases: null
  samples:
    - "O+"
    - "A-"
    - "AB"
    - "B+"
  references: null
  notes: >
    v1 migration: Was person.blood_type. Transform uppercases. Decompose
    extracts blood group (A, B, AB, O) and Rh factor (+, -, or null).

identity.person.height:
  title: "Height"
  description: >
    Person height in cm, inches, or feet.inches format (e.g., 180cm, 5'10", 180).
    Transforms to DOUBLE (centimeters). Decompose extracts value and unit.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: DOUBLE
  format_string: null
  transform: >
    CASE
      WHEN UPPER({col}) LIKE '%FT%' OR {col} LIKE '%\\''%' THEN
        (CAST(REGEXP_EXTRACT({col}, '^([0-9]+)') AS DOUBLE) * 30.48) +
        (CAST(COALESCE(REGEXP_EXTRACT({col}, '\\'([0-9]+)'), '0') AS DOUBLE) * 2.54)
      WHEN UPPER({col}) LIKE '%IN%' THEN CAST(REGEXP_EXTRACT({col}, '^([0-9.]+)') AS DOUBLE) * 2.54
      ELSE CAST(REGEXP_EXTRACT({col}, '^([0-9.]+)') AS DOUBLE)
    END
  transform_ext: null
  decompose:
    value: "CAST(REGEXP_EXTRACT({col}, '^([0-9.]+)') AS DOUBLE)"
    unit: "UPPER(COALESCE(REGEXP_EXTRACT({col}, '([A-Z]+)$'), CASE WHEN LENGTH({col}) > 10 THEN 'CM' ELSE 'INCH' END))"
  validation:
    type: string
    pattern: "^[0-9]+(\\.[0-9]+)?\\s*(cm|in|ft|inches|feet)?$|^[0-9]+'[0-9]+\"$"
  tier: [DOUBLE, person]
  release_priority: 2
  aliases: null
  samples:
    - "180 cm"
    - "5'10\""
    - "70 inches"
    - "6 ft"
  references: null
  notes: >
    v1 migration: Was person.height. Transform converts to centimeters.
    Handles ft'in" notation, inches, cm, feet. Decompose extracts value and unit.

identity.person.weight:
  title: "Weight"
  description: >
    Person weight in kg, lbs, or other units (e.g., 75kg, 165lbs).
    Transforms to DOUBLE (kilograms). Decompose extracts value and unit.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: DOUBLE
  format_string: null
  transform: >
    CASE
      WHEN UPPER({col}) LIKE '%LB%' THEN CAST(REGEXP_EXTRACT({col}, '^([0-9.]+)') AS DOUBLE) / 2.20462
      ELSE CAST(REGEXP_EXTRACT({col}, '^([0-9.]+)') AS DOUBLE)
    END
  transform_ext: null
  decompose:
    value: "CAST(REGEXP_EXTRACT({col}, '^([0-9.]+)') AS DOUBLE)"
    unit: "UPPER(COALESCE(REGEXP_EXTRACT({col}, '([A-Z]+)$'), CASE WHEN CAST(REGEXP_EXTRACT({col}, '^([0-9.]+)') AS DOUBLE) > 100 THEN 'LBS' ELSE 'KG' END))"
  validation:
    type: string
    pattern: "^[0-9]+(\\.[0-9]+)?\\s*(kg|lbs|lb|g|oz|stones)?$"
  tier: [DOUBLE, person]
  release_priority: 2
  aliases: null
  samples:
    - "75 kg"
    - "165 lbs"
    - "68.5 kg"
    - "170 pounds"
  references: null
  notes: >
    v1 migration: Was person.weight. Transform converts to kilograms.
    Handles kg, lbs, pounds, stones. Decompose extracts value and unit.

identity.person.age:
  title: "Age"
  description: >
    Person age in years. Numeric string or integer. When inferred as VARCHAR,
    transforms to SMALLINT.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: SMALLINT
  format_string: null
  transform: "CAST({col} AS SMALLINT)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    pattern: "^[0-9]{1,3}$"
    minimum: 0
    maximum: 150
  tier: [SMALLINT, person]
  release_priority: 4
  aliases: null
  samples:
    - "25"
    - "42"
    - "7"
  references: null
  notes: >
    v1 migration: Not explicitly in v1 but inferred from person data.
    Reasonable range: 0-150 years. Useful for age-based filtering and analytics.

identity.person.occupation:
  title: "Occupation"
  description: >
    Job title or profession (Engineer, Manager, Teacher, etc.).
    Broad categorization due to variance in naming and standardization.
  designation: broad_words
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    minLength: 2
    maxLength: 100
  tier: [VARCHAR, person]
  release_priority: 1
  aliases: [job_title, profession]
  samples:
    - "Software Engineer"
    - "Data Scientist"
    - "Product Manager"
    - "Nurse"
  references: null
  notes: >
    v1 migration: Was person.occupation marked broad_words. No strict validation
    beyond length. Consider ISCO (International Standard Classification of
    Occupations) for standardization.

# ═════════════════════════════════════════════════════════════════════
# CATEGORY: payment
#
# Financial identifiers and payment methods. Sensitive PII; handle with care.
# ═════════════════════════════════════════════════════════════════════

identity.payment.credit_card_number:
  title: "Credit Card Number"
  description: >
    Credit card or debit card primary account number (PAN).
    Typically 13-19 digits. Last digit is check digit (Luhn algorithm).
    HIGHLY SENSITIVE — encrypt immediately in production.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose:
    issuer_identification_number: "REGEXP_EXTRACT({col}, '^([0-9]{6})')"
    card_type: "CASE WHEN {col} LIKE '4%' THEN 'Visa' WHEN {col} LIKE '5[1-5]%' THEN 'Mastercard' WHEN {col} LIKE '3[47]%' THEN 'Amex' ELSE 'Other' END"
    last_four: "REGEXP_EXTRACT({col}, '([0-9]{4})$')"
  validation:
    type: string
    pattern: "^[0-9]{13,19}$"
  tier: [VARCHAR, payment]
  release_priority: 4
  aliases: [pan, credit_card]
  samples:
    - "4532015112830366"
    - "5425233010103442"
    - "374245455400126"
  references: null
  notes: >
    v1 migration: Was payment.credit_card_number. Check digit uses Luhn algorithm
    (validated in crate, not SQL). MUST be encrypted/tokenized in production.
    PCI DSS compliance required. Decompose extracts issuer ID, card type, last 4.

identity.payment.credit_card_expiration_date:
  title: "Credit Card Expiration Date"
  description: >
    Credit card expiration date in MM/YY or MM/YYYY format.
    Transforms to DATE (end of month).
  designation: universal
  locales: [UNIVERSAL]
  broad_type: DATE
  format_string: "%m/%y"
  transform: "DATE_TRUNC('month', CAST(CONCAT('20', REGEXP_EXTRACT({col}, '^([0-9]{2})/([0-9]{2})$'), '-', REGEXP_EXTRACT({col}, '^([0-9]{2})) AS DATE) + INTERVAL '1 month' - INTERVAL '1 day')"
  transform_ext: null
  decompose:
    month: "CAST(REGEXP_EXTRACT({col}, '^([0-9]{2})') AS SMALLINT)"
    year: "CAST(REGEXP_EXTRACT({col}, '/([0-9]{2,4})$') AS SMALLINT)"
  validation:
    type: string
    pattern: "^(0[1-9]|1[0-2])/([0-9]{2}|[0-9]{4})$"
  tier: [DATE, payment]
  release_priority: 4
  aliases: [card_expiry]
  samples:
    - "12/25"
    - "06/28"
    - "03/2026"
  references: null
  notes: >
    v1 migration: Was payment.credit_card_expiration_date. Transform converts
    MM/YY to end-of-month DATE. Decompose extracts month and year separately.
    Typical format: MM/YY (e.g., 12/25 for December 2025).

identity.payment.cvv:
  title: "CVV / CVC"
  description: >
    Card Verification Value (CVV/CVV2 for Visa/MC) or CVC (American Express).
    3 digits (4 for Amex). HIGHLY SENSITIVE — never store.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    pattern: "^[0-9]{3,4}$"
  tier: [VARCHAR, payment]
  release_priority: 3
  aliases: [cvc, cvc2]
  samples:
    - "123"
    - "4567"
  references: null
  notes: >
    v1 migration: Was payment.cvv. NEVER store CVV in databases per PCI DSS.
    If detected, immediately alert and investigate. 3 digits for most cards,
    4 digits for Amex (front, not back).

identity.payment.credit_card_network:
  title: "Credit Card Network"
  description: >
    Payment card network (Visa, Mastercard, American Express, Discover, etc.).
    Inferred from card number prefix. Broad categorization.
  designation: broad_words
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    enum:
      - Visa
      - Mastercard
      - Amex
      - Discover
      - Diners Club
      - JCB
  tier: [VARCHAR, payment]
  release_priority: 1
  aliases: [card_issuer, card_brand]
  samples:
    - "Visa"
    - "Mastercard"
    - "Amex"
    - "Discover"
  references: null
  notes: >
    v1 migration: Was payment.credit_card_network marked broad_words.
    Can be inferred from card number but also may appear as explicit string.

identity.payment.bitcoin_address:
  title: "Bitcoin Address"
  description: >
    Bitcoin wallet address. P2PKH format starts with 1, P2SH with 3, P2WPKH with bc1.
    26-35 characters. Base58Check encoding.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose:
    address_type: "CASE WHEN {col} LIKE '1%' THEN 'P2PKH' WHEN {col} LIKE '3%' THEN 'P2SH' WHEN {col} LIKE 'bc1%' THEN 'P2WPKH' ELSE 'Unknown' END"
  validation:
    type: string
    pattern: "^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$|^bc1[a-z0-9]{39,59}$"
  tier: [VARCHAR, payment]
  release_priority: 3
  aliases: null
  samples:
    - "1A1z7agoat2GPFH7pPPPP..."
    - "3J98t1WpEZ73CNmYviecrnyiWrnqRhWNLy"
    - "bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4"
  references: null
  notes: >
    v1 migration: Was payment.bitcoin_address. Pattern covers P2PKH (1..),
    P2SH (3..), P2WPKH (bc1...). Addresses are not case-sensitive but typically
    use mixed case for checksums.

identity.payment.ethereum_address:
  title: "Ethereum Address"
  description: >
    Ethereum wallet or contract address. 42 characters: 0x + 40 hex digits.
    May be EIP-55 checksummed (mixed case) or not.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "LOWER(CAST({col} AS VARCHAR))"
  transform_ext: null
  decompose: null
  validation:
    type: string
    pattern: "^0x[a-fA-F0-9]{40}$"
  tier: [VARCHAR, payment]
  release_priority: 3
  aliases: null
  samples:
    - "0x742d35Cc6634C0532925a3b844Bc3e7c1f2B9C2C"
    - "0x0000000000000000000000000000000000000000"
    - "0xd9965507d3b0ce0ce6932b0337db0c11b85fcf7d"
  references: null
  notes: >
    v1 migration: Was payment.ethereum_address. Transform lowercases.
    EIP-55 checksummed addresses use mixed case but lowercase canonical form
    is preferable for storage.

identity.payment.paypal_email:
  title: "PayPal Email"
  description: >
    Email address associated with a PayPal account. Format is standard email.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "LOWER(CAST({col} AS VARCHAR))"
  transform_ext: null
  decompose:
    local: "REGEXP_EXTRACT(LOWER({col}), '^([^@]+)')"
    domain: "REGEXP_EXTRACT(LOWER({col}), '@(.+)$')"
  validation:
    type: string
    pattern: "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$"
  tier: [VARCHAR, payment]
  release_priority: 2
  aliases: [paypal_account]
  samples:
    - "user@example.com"
    - "merchant+paypal@business.org"
  references: null
  notes: >
    v1 migration: Was payment.paypal. Standard email format; same as
    identity.person.email but explicitly PayPal context.

identity.payment.isin:
  title: "ISIN"
  description: >
    International Securities Identification Number. 12-character alphanumeric code
    that uniquely identifies a specific securities issue. Format: 2-letter country
    code (ISO 3166-1) + 9-character alphanumeric NSIN + 1 check digit (Luhn on
    alpha-to-numeric conversion where A=10, B=11, ..., Z=35).
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose:
    country: "SUBSTRING({col}, 1, 2)"
    nsin: "SUBSTRING({col}, 3, 9)"
    check_digit: "SUBSTRING({col}, 12, 1)"
  validation:
    type: string
    pattern: "^[A-Z]{2}[A-Z0-9]{9}[0-9]$"
  tier: [VARCHAR, payment]
  release_priority: 3
  aliases: null
  samples:
    - "US0378331005"
    - "GB0002634946"
    - "JP3633400001"
    - "DE0007164600"
  references: null
  notes: >
    New in v2. ISIN is the global standard for securities identification (ISO 6166).
    The check digit uses the Luhn algorithm applied to the full string after converting
    letters to numbers (A=10, B=11, ..., Z=35). Country code follows ISO 3166-1 alpha-2.

identity.payment.cusip:
  title: "CUSIP"
  description: >
    Committee on Uniform Securities Identification Procedures identifier.
    9-character alphanumeric code for US and Canadian securities. Format:
    6-character issuer code + 2-character issue number + 1 check digit.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose:
    issuer: "SUBSTRING({col}, 1, 6)"
    issue: "SUBSTRING({col}, 7, 2)"
    check_digit: "SUBSTRING({col}, 9, 1)"
  validation:
    type: string
    pattern: "^[A-Z0-9]{8}[0-9]$"
  tier: [VARCHAR, payment]
  release_priority: 3
  aliases: null
  samples:
    - "037833100"
    - "17275R102"
    - "594918104"
  references: null
  notes: >
    New in v2. CUSIP is the primary identifier for US/Canadian securities.
    Check digit uses a custom weighted algorithm where characters at even positions
    are doubled (similar to Luhn but with alphanumeric conversion).

identity.payment.sedol:
  title: "SEDOL"
  description: >
    Stock Exchange Daily Official List code. 7-character identifier for
    UK and Irish securities. Format: 6 alphanumeric characters + 1 check digit
    (weighted sum with weights 1,3,1,7,3,9 mod 10).
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    pattern: "^[B-DF-HJ-NP-TV-Z0-9]{6}[0-9]$"
  tier: [VARCHAR, payment]
  release_priority: 3
  aliases: null
  samples:
    - "0263494"
    - "B0WNLY7"
    - "3134865"
  references: null
  notes: >
    New in v2. SEDOL codes never contain vowels (to avoid forming words).
    The check digit is computed as (10 - (weighted_sum mod 10)) mod 10
    with weights [1, 3, 1, 7, 3, 9] applied to the first 6 characters
    (digits 0-9 have face value, letters B=11, C=12, ..., Z=35, skipping vowels).

identity.payment.swift_bic:
  title: "SWIFT/BIC"
  description: >
    Society for Worldwide Interbank Financial Telecommunication code (also called
    Bank Identifier Code). 8 or 11 character code identifying financial institutions.
    Format: 4-letter bank code + 2-letter country code (ISO 3166) + 2-character
    location code + optional 3-character branch code.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "UPPER(CAST({col} AS VARCHAR))"
  transform_ext: null
  decompose:
    bank_code: "SUBSTRING({col}, 1, 4)"
    country_code: "SUBSTRING({col}, 5, 2)"
    location_code: "SUBSTRING({col}, 7, 2)"
    branch_code: "CASE WHEN LENGTH({col}) = 11 THEN SUBSTRING({col}, 9, 3) ELSE NULL END"
  validation:
    type: string
    pattern: "^[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}([A-Z0-9]{3})?$"
  tier: [VARCHAR, payment]
  release_priority: 3
  aliases: [bic, swift_code]
  samples:
    - "DEUTDEFF"
    - "BNPAFRPP"
    - "CHASUS33XXX"
    - "BOFAUS3N"
  references: null
  notes: >
    New in v2. SWIFT/BIC codes are used for international wire transfers.
    8-character codes identify the head office; 11-character codes include a
    branch identifier. "XXX" as branch code also means head office.

identity.payment.lei:
  title: "LEI"
  description: >
    Legal Entity Identifier. 20-character alphanumeric code that uniquely identifies
    legal entities participating in financial transactions. Format: 4-digit LOU
    (Local Operating Unit) prefix + 14-character entity identifier + 2 check digits
    (ISO 7064 Mod 97-10, same algorithm as IBAN check digits).
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose:
    lou_prefix: "SUBSTRING({col}, 1, 4)"
    entity_id: "SUBSTRING({col}, 5, 14)"
    check_digits: "SUBSTRING({col}, 19, 2)"
  validation:
    type: string
    pattern: "^[0-9]{4}[A-Z0-9]{14}[0-9]{2}$"
  tier: [VARCHAR, payment]
  release_priority: 3
  aliases: [legal_entity_identifier]
  samples:
    - "529900T8BM49AURSDO55"
    - "213800WSGIIZCXF1P572"
    - "549300MLUDYVRQOOXS22"
  references: null
  notes: >
    New in v2. LEI was introduced after the 2008 financial crisis for entity
    identification in financial transactions. Check digits use ISO 7064 Mod 97-10:
    convert letters to numbers (A=10..Z=35), compute mod 97, check digits = 98 - remainder.

identity.payment.currency_code:
  title: "Currency Code (ISO 4217)"
  description: >
    Three-letter currency code as defined by ISO 4217. Examples: USD, EUR, GBP, JPY.
    Used in financial data, trading systems, and international commerce.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "UPPER(CAST({col} AS VARCHAR))"
  transform_ext: null
  decompose: null
  validation:
    type: string
    pattern: "^[A-Z]{3}$"
  tier: [VARCHAR, payment]
  release_priority: 3
  aliases: [iso_4217, currency_iso]
  samples:
    - "USD"
    - "EUR"
    - "GBP"
    - "JPY"
    - "CHF"
    - "AUD"
  references: null
  notes: >
    v1 migration: Was finance.currency_iso_code. Three uppercase letters.
    First two letters usually match ISO 3166-1 country code (US→USD, GB→GBP),
    third letter is typically initial of currency name (D→Dollar, P→Pound).

identity.payment.currency_symbol:
  title: "Currency Symbol"
  description: >
    Unicode currency symbol character. Examples: $, €, £, ¥, ₹, ₩, ₿.
    Single character (or short sequence) representing a currency.
  designation: universal
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    pattern: "^[\\p{Sc}]+$"
  tier: [VARCHAR, payment]
  release_priority: 2
  aliases: [currency_sign]
  samples:
    - "$"
    - "€"
    - "£"
    - "¥"
    - "₹"
    - "₩"
    - "₿"
  references: null
  notes: >
    v1 migration: Was finance.currency_symbol. Uses Unicode currency symbol
    category (\\p{Sc}). Short strings — typically 1 character. Low priority
    due to ambiguity ($ could be USD, AUD, CAD, etc.).

# ═════════════════════════════════════════════════════════════════════
# CATEGORY: academic
#
# Education and academic credentials.
# ═════════════════════════════════════════════════════════════════════

identity.academic.degree:
  title: "Academic Degree"
  description: >
    University degree (Bachelor's, Master's, PhD, etc.).
    Broad categorization.
  designation: broad_words
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    enum:
      - "High School Diploma"
      - "Associate Degree"
      - "Bachelor Degree"
      - "Master Degree"
      - "PhD"
      - "Professional Certificate"
  tier: [VARCHAR, academic]
  release_priority: 1
  aliases: null
  samples:
    - "Bachelor Degree"
    - "Master's"
    - "PhD"
    - "Associate"
  references: null
  notes: >
    v1 migration: Was person.academic_degree marked broad_words. Enum is
    illustrative; actual values depend on data. Consider standardizing to
    ISCED (International Standard Classification of Education).

identity.academic.university:
  title: "University / Institution"
  description: >
    Name of educational institution (university, college, school).
    Broad categorization due to name variance.
  designation: broad_words
  locales: [UNIVERSAL]
  broad_type: VARCHAR
  format_string: null
  transform: "CAST({col} AS VARCHAR)"
  transform_ext: null
  decompose: null
  validation:
    type: string
    minLength: 3
    maxLength: 200
  tier: [VARCHAR, academic]
  release_priority: 1
  aliases: [school, college, institution]
  samples:
    - "Harvard University"
    - "Stanford University"
    - "MIT"
    - "Oxford University"
  references: null
  notes: >
    v1 migration: Was person.university marked broad_words. No strict validation.
